diff --git a/src/AudioGeneratorAAC.cpp b/src/AudioGeneratorAAC.cpp
index c756867..fa160c1 100644
--- a/src/AudioGeneratorAAC.cpp
+++ b/src/AudioGeneratorAAC.cpp
@@ -34,13 +34,13 @@ AudioGeneratorAAC::AudioGeneratorAAC()
   buff = (uint8_t*)malloc(buffLen);
   outSample = (int16_t*)malloc(1024 * 2 * sizeof(uint16_t));
   if (!buff || !outSample) {
-    audioLogger->printf_P(PSTR("ERROR: Out of memory in AAC\n"));
+    debug_w("ERROR: Out of memory in AAC");
     Serial.flush();
   }
 
   hAACDecoder = AACInitDecoder();
   if (!hAACDecoder) {
-    audioLogger->printf_P(PSTR("Out of memory error! hAACDecoder==NULL\n"));
+    debug_w("Out of memory error! hAACDecoder==NULL");
     Serial.flush();
   }
 
@@ -69,12 +69,12 @@ AudioGeneratorAAC::AudioGeneratorAAC(void *preallocateData, int preallocateSz)
   int used = p - (uint8_t*)preallocateSpace;
   int availSpace = preallocateSize - used;
   if (availSpace < 0 ) {
-    audioLogger->printf_P(PSTR("ERROR: Out of memory in AAC\n"));
+    debug_e("ERROR: Out of memory in AAC");
   }
 
   hAACDecoder = AACInitDecoderPre(p, availSpace);
   if (!hAACDecoder) {
-    audioLogger->printf_P(PSTR("Out of memory error! hAACDecoder==NULL\n"));
+    debug_w("Out of memory error! hAACDecoder==NULL");
     Serial.flush();
   }
   buffValid = 0;
diff --git a/src/AudioGeneratorFLAC.cpp b/src/AudioGeneratorFLAC.cpp
index f315133..48c2b6a 100644
--- a/src/AudioGeneratorFLAC.cpp
+++ b/src/AudioGeneratorFLAC.cpp
@@ -190,7 +190,7 @@ void AudioGeneratorFLAC::metadata_cb(const FLAC__StreamDecoder *decoder, const F
 {
   (void) decoder;
   (void) metadata;
-  audioLogger->printf_P(PSTR("Metadata\n"));
+  debug_d("Metadata");
 }
 char AudioGeneratorFLAC::error_cb_str[64];
 void AudioGeneratorFLAC::error_cb(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status)
diff --git a/src/AudioGeneratorMP3.cpp b/src/AudioGeneratorMP3.cpp
index d962c9e..cfab83a 100644
--- a/src/AudioGeneratorMP3.cpp
+++ b/src/AudioGeneratorMP3.cpp
@@ -153,7 +153,7 @@ enum mad_flow AudioGeneratorMP3::Input()
 
 void AudioGeneratorMP3::desync ()
 {
-    audioLogger->printf_P(PSTR("MP3:desync\n"));
+    debug_d("MP3:desync\n");
     if (stream) {
         stream->next_frame = nullptr;
         stream->this_frame = nullptr;
@@ -193,7 +193,7 @@ bool AudioGeneratorMP3::GetOneSample(int16_t sample[2])
     
     switch ( mad_synth_frame_onens(synth, frame, nsCount++) ) {
         case MAD_FLOW_STOP:
-        case MAD_FLOW_BREAK: audioLogger->printf_P(PSTR("msf1ns failed\n"));
+        case MAD_FLOW_BREAK: debug_w("msf1ns failed");
           return false; // Either way we're done
         default:
           break; // Do nothing
@@ -228,7 +228,7 @@ retry:
         if (stream->error == MAD_ERROR_BUFLEN) {
           // randomly seeking can lead to endless
           // and unrecoverable "MAD_ERROR_BUFLEN" loop
-          audioLogger->printf_P(PSTR("MP3:ERROR_BUFLEN %d\n"), unrecoverable);
+          debug_w("MP3:ERROR_BUFLEN %d", unrecoverable);
           if (++unrecoverable >= 3) {
             unrecoverable = 0;
             stop();
@@ -244,7 +244,7 @@ retry:
     }
 
     if (!GetOneSample(lastSample)) {
-      audioLogger->printf_P(PSTR("G1S failed\n"));
+      debug_w("G1S failed");
       running = false;
       goto done;
     }
@@ -266,7 +266,7 @@ bool AudioGeneratorMP3::begin(AudioFileSource *source, AudioOutput *output)
   if (!output) return false;
   this->output = output;
   if (!file->isOpen()) {
-    audioLogger->printf_P(PSTR("MP3 source file not open\n"));
+    debug_w("MP3 source file not open");
     return false; // Error
   }
 
@@ -298,7 +298,7 @@ bool AudioGeneratorMP3::begin(AudioFileSource *source, AudioOutput *output)
       synth = reinterpret_cast<struct mad_synth *>(preallocateSynthSpace);
     }
     else {
-      audioLogger->printf_P("OOM error in MP3:  Want %d/%d/%d/%d bytes, have %d/%d/%d/%d bytes preallocated.\n",
+      debug_e("OOM error in MP3:  Want %d/%d/%d/%d bytes, have %d/%d/%d/%d bytes preallocated.",
           preAllocBuffSize(), preAllocStreamSize(), preAllocFrameSize(), preAllocSynthSize(),
           preallocateSize, preallocateStreamSize, preallocateFrameSize, preallocateSynthSize);
       return false;
@@ -315,7 +315,7 @@ bool AudioGeneratorMP3::begin(AudioFileSource *source, AudioOutput *output)
     p += preAllocSynthSize();
     int neededBytes = p - reinterpret_cast<uint8_t *>(preallocateSpace);
     if (neededBytes > preallocateSize) {
-      audioLogger->printf_P("OOM error in MP3:  Want %d bytes, have %d bytes preallocated.\n", neededBytes, preallocateSize);
+      debug_e("OOM error in MP3:  Want %d bytes, have %d bytes preallocated.", neededBytes, preallocateSize);
       return false;
     }
   } else {
@@ -362,7 +362,8 @@ extern "C" {
   {
     return 8192;
   }
-#elif defined(ESP8266) && !defined(CORE_MOCK)
+// #elif defined(ESP8266) && !defined(CORE_MOCK)
+#elif 0
   #include <cont.h>
   extern cont_t g_cont;
 
@@ -376,13 +377,13 @@ extern "C" {
     if ((freestack < 512) || (freeheap < 5120)) {
       static int laststack, lastheap;
       if (laststack!=freestack|| lastheap !=freeheap) {
-        audioLogger->printf_P(PSTR("%s: FREESTACK=%d, FREEHEAP=%d\n"), s, /*t, i,*/ freestack, /*cont_get_free_stack(&g_cont),*/ freeheap);
+        debug_d("%s: FREESTACK=%d, FREEHEAP=%d\n", s, /*t, i,*/ freestack, /*cont_get_free_stack(&g_cont),*/ freeheap);
       }
       if (freestack < 256) {
-        audioLogger->printf_P(PSTR("out of stack!\n"));
+        debug_w("out of stack!");
       }
       if (freeheap < 1024) {
-        audioLogger->printf_P(PSTR("out of heap!\n"));
+        debug_w("out of heap!\n");
       }
       Serial.flush();
       laststack = freestack;
diff --git a/src/AudioGeneratorMP3a.cpp b/src/AudioGeneratorMP3a.cpp
index f75846a..fe2eb5d 100644
--- a/src/AudioGeneratorMP3a.cpp
+++ b/src/AudioGeneratorMP3a.cpp
@@ -30,7 +30,7 @@ AudioGeneratorMP3a::AudioGeneratorMP3a()
   output = NULL;
   hMP3Decoder = MP3InitDecoder();
   if (!hMP3Decoder) {
-    audioLogger->printf_P(PSTR("Out of memory error! hMP3Decoder==NULL\n"));
+    debug_w("Out of memory error! hMP3Decoder==NULL");
     Serial.flush();
   }
   // For sanity's sake...
diff --git a/src/AudioGeneratorWAV.cpp b/src/AudioGeneratorWAV.cpp
index 6c8f7a2..e835ece 100644
--- a/src/AudioGeneratorWAV.cpp
+++ b/src/AudioGeneratorWAV.cpp
@@ -123,34 +123,34 @@ bool AudioGeneratorWAV::ReadWAVInfo()
 
   // Header == "RIFF"
   if (!ReadU32(&u32)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   if (u32 != 0x46464952) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, invalid RIFF header, got: %08X \n"), (uint32_t) u32);
+    Serial.printf(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, invalid RIFF header, got: %08X "), (uint32_t) u32);
     return false;
   }
 
   // Skip ChunkSize
   if (!ReadU32(&u32)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
 
   // Format == "WAVE"
   if (!ReadU32(&u32)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   if (u32 != 0x45564157) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, invalid WAVE header, got: %08X \n"), (uint32_t) u32);
+    Serial.printf(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, invalid WAVE header, got: %08X "), (uint32_t) u32);
     return false;
   }
 
   // there might be JUNK or PAD - ignore it by continuing reading until we get to "fmt "
   while (1) {
     if (!ReadU32(&u32)) {
-      Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+      Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
       return false;
     };
     if (u32 == 0x20746d66) break; // 'fmt '
@@ -158,64 +158,64 @@ bool AudioGeneratorWAV::ReadWAVInfo()
 
   // subchunk size
   if (!ReadU32(&u32)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   if (u32 == 16) { toSkip = 0; }
   else if (u32 == 18) { toSkip = 18 - 16; }
   else if (u32 == 40) { toSkip = 40 - 16; }
   else {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, appears not to be standard PCM \n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, appears not to be standard PCM "));
     return false;
   } // we only do standard PCM
 
   // AudioFormat
   if (!ReadU16(&u16)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   if (u16 != 1) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, AudioFormat appears not to be standard PCM \n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, AudioFormat appears not to be standard PCM "));
     return false;
   } // we only do standard PCM
 
   // NumChannels
   if (!ReadU16(&channels)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   if ((channels<1) || (channels>2)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, only mono and stereo are supported \n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, only mono and stereo are supported "));
     return false;
   } // Mono or stereo support only
 
   // SampleRate
   if (!ReadU32(&sampleRate)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   if (sampleRate < 1) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, unknown sample rate \n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, unknown sample rate "));
     return false;
   }  // Weird rate, punt.  Will need to check w/DAC to see if supported
 
   // Ignore byterate and blockalign
   if (!ReadU32(&u32)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   if (!ReadU16(&u16)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
 
   // Bits per sample
   if (!ReadU16(&bitsPerSample)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   if ((bitsPerSample!=8) && (bitsPerSample != 16)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, only 8 or 16 bits is supported \n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, only 8 or 16 bits is supported "));
     return false;
   }  // Only 8 or 16 bits
 
@@ -223,7 +223,7 @@ bool AudioGeneratorWAV::ReadWAVInfo()
   while (toSkip) {
     uint8_t ign;
     if (!ReadU8(&ign)) {
-      Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+      Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
       return false;
     };
     toSkip--;
@@ -233,28 +233,28 @@ bool AudioGeneratorWAV::ReadWAVInfo()
   do {
     // id == "data"
     if (!ReadU32(&u32)) {
-      Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+      Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
       return false;
     };
     if (u32 == 0x61746164) break; // "data"
     // Skip size, read until end of chunk
     if (!ReadU32(&u32)) {
-      Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+      Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
       return false;
     };
     if(!file->seek(u32, SEEK_CUR)) {
-      Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data, seek failed\n"));
+      Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data, seek failed"));
       return false;
     }
   } while (1);
   if (!file->isOpen()) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, file is not open\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, file is not open"));
     return false;
   };
 
   // Skip size, read until end of file...
   if (!ReadU32(&u32)) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data\n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: failed to read WAV data"));
     return false;
   };
   availBytes = u32;
@@ -262,7 +262,7 @@ bool AudioGeneratorWAV::ReadWAVInfo()
   // Now set up the buffer or fail
   buff = reinterpret_cast<uint8_t *>(malloc(buffSize));
   if (!buff) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, failed to set up buffer \n"));
+    Serial.println(F("AudioGeneratorWAV::ReadWAVInfo: cannot read WAV, failed to set up buffer "));
     return false;
   };
   buffPtr = 0;
@@ -274,39 +274,39 @@ bool AudioGeneratorWAV::ReadWAVInfo()
 bool AudioGeneratorWAV::begin(AudioFileSource *source, AudioOutput *output)
 {
   if (!source) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::begin: failed: invalid source\n"));
+    Serial.println(F("AudioGeneratorWAV::begin: failed: invalid source"));
     return false;
   }
   file = source;
   if (!output) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::begin: invalid output\n"));
+    Serial.println(F("AudioGeneratorWAV::begin: invalid output"));
     return false;
   }
   this->output = output;
   if (!file->isOpen()) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::begin: file not open\n"));
+    Serial.println(F("AudioGeneratorWAV::begin: file not open"));
     return false;
   } // Error
 
   if (!ReadWAVInfo()) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::begin: failed during ReadWAVInfo\n"));
+    Serial.println(F("AudioGeneratorWAV::begin: failed during ReadWAVInfo"));
     return false;
   }
 
   if (!output->SetRate( sampleRate )) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::begin: failed to SetRate in output\n"));
+    Serial.println(F("AudioGeneratorWAV::begin: failed to SetRate in output"));
     return false;
   }
   if (!output->SetBitsPerSample( bitsPerSample )) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::begin: failed to SetBitsPerSample in output\n"));
+    Serial.println(F("AudioGeneratorWAV::begin: failed to SetBitsPerSample in output"));
     return false;
   }
   if (!output->SetChannels( channels )) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::begin: failed to SetChannels in output\n"));
+    Serial.println(F("AudioGeneratorWAV::begin: failed to SetChannels in output"));
     return false;
   }
   if (!output->begin()) {
-    Serial.printf_P(PSTR("AudioGeneratorWAV::begin: output's begin did not return true\n"));
+    Serial.println(F("AudioGeneratorWAV::begin: output's begin did not return true"));
     return false;
   }
 
diff --git a/src/AudioOutputSerialWAV.cpp b/src/AudioOutputSerialWAV.cpp
index 458860f..b462ae3 100644
--- a/src/AudioOutputSerialWAV.cpp
+++ b/src/AudioOutputSerialWAV.cpp
@@ -72,7 +72,7 @@ bool AudioOutputSerialWAV::ConsumeSample(int16_t sample[2])
 
 bool AudioOutputSerialWAV::stop()
 {
-  audioLogger->printf_P(PSTR("\n\n\nEOF\n\n\n"));
+  debug_d("\n\n\nEOF\n\n\n");
   return true;
 }
  
